import React, { useState, useEffect } from 'react';
import Pagination from './Pagination';

const Joi = require('joi');
const Employees = require('../data_modules/Employees.json');
const roles = require('../data_modules/Roles.json');
const departments = require('../data_modules/Departments.json');
const validRoles = roles.map(role => role.name);
const validDepartments = departments.map(dept => dept.name);

//wanted to use something which would define a structure of an json object
//So if any bad data came with it, I could filter it
const employeeSchema = Joi.object({
    name: Joi.string().required(),
    department: Joi.string().valid(...validDepartments).required(),
    role: Joi.string().valid(...validRoles).required()
});


//this function filters bad data and only takes valiid json object for the table
const filterInvalidEmployees = (data) => {
    return data.filter((employee) => {
        const { error } = employeeSchema.validate(employee);
        if (!error) {
            return true;
        }
        return false;
    });
};

function GetAllEmployees() {
    try {
        const localStorageEmployees = JSON.parse(localStorage.getItem('employees')) || [];
        const allEmployees = [...Employees, ...localStorageEmployees];
        return filterInvalidEmployees(allEmployees);
    } catch (error) {
        console.error('Error reading data:', error);
        return [];
    }
}

function EmployeesTable() {
    const [searchName, setSearchName] = useState('');
    const [searchDepartment, setSearchDepartment] = useState('');
    const [sortOrder, setSortOrder] = useState('none');
    const [currentPage, setCurrentPage] = useState(1);
    const rowsPerPage = 10;

    const filteredEmployees = GetAllEmployees().filter((employee) => {
        return (
            employee.name.toLowerCase().includes(searchName.toLowerCase()) &&
            employee.department.toLowerCase().includes(searchDepartment.toLowerCase())
        );
    });

    const sortedEmployees = [...filteredEmployees].sort((a, b) => {
        if (sortOrder === 'asc') {
            return a.name.localeCompare(b.name);
        } else if (sortOrder === 'desc') {
            return b.name.localeCompare(a.name);
        } else {
            return 0;
        }
    });

    useEffect(() => {
        //so whenever change happens page returns to the first page 
        //I realised it is not really correct in case I searched "Ja" and then I added "n" and it became "Jan"
        //now it works, fine but when you have a lot of data, you might also have few pages of "Jan"
        //and I am not sure that returning to the first page is in that case right choice. I don't have much time to think better way now,
        // but I will play it around later
        setCurrentPage(1);
    }, [searchName, searchDepartment, sortOrder]);
    
    const indexOfLastRow = currentPage * rowsPerPage;
    const indexOfFirstRow = indexOfLastRow - rowsPerPage;
    const currentRows = sortedEmployees.slice(indexOfFirstRow, indexOfLastRow);
    const totalPages = Math.ceil(sortedEmployees.length / rowsPerPage);

    const handlePageChange = (pageNumber) => {
        setCurrentPage(pageNumber);
    };

    const handleSort = () => {
        if (sortOrder === 'none') {
            setSortOrder('asc');
        } else if (sortOrder === 'asc') {
            setSortOrder('desc');
        } else {
            setSortOrder('none');
        }
    };

    return (
        <div className="employees-table-container">
            <h2>Employees</h2>
            <table className="employees-table">
                <thead>
                    <tr>
                        <th>
                            <label onClick={handleSort} style={{ cursor: 'pointer' }}>
                                Name {sortOrder === 'asc' && ' ↑'}
                                {sortOrder === 'desc' && ' ↓'}
                                {sortOrder === 'none' && ' ↑↓'}
                            </label>
                            <input
                                type="text"
                                placeholder="Search by name..."
                                value={searchName}
                                onChange={(e) => setSearchName(e.target.value)}
                                className="search-input"
                            />
                        </th>
                        <th>
                            Department
                            <input
                                type="text"
                                placeholder="Search by department..."
                                value={searchDepartment}
                                onChange={(e) => setSearchDepartment(e.target.value)}
                                className="search-input"
                            />
                        </th>
                        <th>
                            Role
                        </th>
                    </tr>
                </thead>
                <tbody>
                    {currentRows.map((employee, index) => (
                        <tr key={index}>
                            <td>{employee.name}</td>
                            <td>{employee.department}</td>
                            <td>{employee.role}</td>
                        </tr>
                    ))}
                </tbody>
            </table>

            {filteredEmployees.length === 0 && (
                <div className="no-match-found">
                    No match found.
                </div>
            )}
            {/* Pagination */}
            {filteredEmployees.length > 0 && (
                <Pagination
                    currentPage={currentPage}
                    totalPages={totalPages}
                    onPageChange={handlePageChange}
                />
            )}
        </div>
    );
}

export default EmployeesTable;